#version 450

#define TG_F32_EPSILON    1.192092896e-07f
#define TG_F32_MAX        3.402823466e+38

layout(local_size_x = 32, local_size_y = 32) in;

layout(set = 0, binding = 0) uniform render_info
{
    vec4         u_camera_position;
    vec4         u_ray00;
    vec4         u_ray01;
    vec4         u_ray10;
    vec4         u_ray11;
    uint         u_directional_light_count;
    uint         u_point_light_count;
    uint         u_sphere_count;
    vec4[512]    u_directional_light_directions;
    vec4[512]    u_directional_light_colors;
    vec4[512]    u_point_light_positions;
    vec4[512]    u_point_light_colors;
    vec4[512]    u_sphere_centers_radii;
};

layout(set = 0, binding = 1, rgba32f) uniform image2D u_render_target;

layout(set = 0, binding = 2) uniform vertex_info
{
    uint    u_vertex_count;
    uint    u_vertex_float_count;
    uint    u_offset_floats_position;
    uint    u_offset_floats_normal;
    uint    u_offset_floats_uv;
    uint    u_offset_floats_tangent;
    uint    u_offset_floats_bitangent;
};

layout(set = 0, binding = 3) buffer vertices
{
    float    u_vertices[];
};

vec3 intersect(vec3 origin, vec3 direction, vec3 p0, vec3 p1, vec3 p2)
{
    vec3 result = vec3(TG_F32_MAX);
    
    vec3 v01 = p1 - p0;
    vec3 v02 = p2 - p0;
    vec3 h = cross(direction, v02);
    float a = dot(v01, h);

    if (a >= TG_F32_EPSILON)
    {
        float f = 1.0 / a;

        vec3 s = origin - p0;
        result.y = dot(s, h) * f;
        
        if (result.y >= 0.0 && result.y <= 1.0)
        {
            vec3 q = cross(s, v01);
            result.z = dot(direction, q) * f;
            
            if (result.z >= 0.0 && result.y + result.z <= 1.0)
            {
                result.x = dot(v02, q) * f;
                if (result.x < TG_F32_EPSILON)
                {
                    result.x = TG_F32_MAX;
                }
            }
        }
    }

    return result;
}

void main()
{
    vec3 colors[5] = vec3[](
        vec3(1.0, 0.2, 0.3),
        vec3(0.4, 0.3, 0.2),
        vec3(0.4, 0.1, 1.0),
        vec3(1.0, 8.0, 0.2),
        vec3(1.0, 0.2, 1.0)
    );
    float x = float(gl_GlobalInvocationID.x) / float(gl_NumWorkGroups.x * gl_WorkGroupSize.x);
    float y = float(gl_GlobalInvocationID.y) / float(gl_NumWorkGroups.y * gl_WorkGroupSize.y);

    vec4 q0 = mix(u_ray00, u_ray10, x);
    vec4 q1 = mix(u_ray01, u_ray11, x);
    vec3 ray = normalize(mix(q1, q0, y).xyz); // TODO: why this order ? q0, q1
    vec3 light_dir = normalize(u_directional_light_directions[0].xyz);

    float best_distance;
    vec4 color = vec4(0.0);
    vec3 ray_dir = normalize(ray);
    vec3 ray_origin = u_camera_position.xyz;
    for (int i = 0; i < 1; i++)
    {
        best_distance = TG_F32_MAX;
        vec3 next_ray_dir = ray_dir;
        vec3 next_ray_origin = ray_origin;
        //for (int j = 0; j < 3 * u_vertex_count; j++)
        for (int j = 0; j < 3 * 100; j++)
        {
            vec3 p0 = vec3(
                u_vertices[(3 * j + 0) * u_vertex_float_count + u_offset_floats_position + 0],
                u_vertices[(3 * j + 0) * u_vertex_float_count + u_offset_floats_position + 1],
                u_vertices[(3 * j + 0) * u_vertex_float_count + u_offset_floats_position + 2]
            );
            vec3 p1 = vec3(
                u_vertices[(3 * j + 1) * u_vertex_float_count + u_offset_floats_position + 0],
                u_vertices[(3 * j + 1) * u_vertex_float_count + u_offset_floats_position + 1],
                u_vertices[(3 * j + 1) * u_vertex_float_count + u_offset_floats_position + 2]
            );
            vec3 p2 = vec3(
                u_vertices[(3 * j + 2) * u_vertex_float_count + u_offset_floats_position + 0],
                u_vertices[(3 * j + 2) * u_vertex_float_count + u_offset_floats_position + 1],
                u_vertices[(3 * j + 2) * u_vertex_float_count + u_offset_floats_position + 2]
            );

            vec3 result = intersect(ray_origin, ray_dir, p0, p1, p2);
            if (result.y >= 0.0 && result.z >= 0.0 && result.y + result.z <= 1.0)
            {
                vec3 p = (1.0 - result.y - result.z) * p0 + result.y * p1 + result.z * p2;
                float distance = distance(ray_origin, p);
                if (distance < best_distance)
                {
                    best_distance = distance;
                    next_ray_origin = ray_origin + result * ray_dir;
                    vec3 normal = normalize(next_ray_origin - normalize(cross(p1 - p0, p2 - p0)));
                    vec3 light_reflect_dir = normalize(reflect(light_dir, normal));

                    float ambient = 0.1f;
                    float diffuse = max(0.0, dot(normal, -light_dir));
                    float specular = pow(max(dot(ray_dir, -light_reflect_dir), 0.0), 16);
                    vec3 c = vec3(1.0, 0.0, 0.0);
                    vec3 l = ambient * c + diffuse * c + specular * c;
                
                    color = vec4(l, 1.0);
                    next_ray_dir = normalize(reflect(ray_dir, normal));
                }
            }
        }
        ray_dir = next_ray_dir;
        ray_origin = next_ray_origin;
    }

    imageStore(u_render_target, ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y), color);
}
