#version 450
#extension GL_ARB_separate_shader_objects : enable

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0, r32f) uniform image3D triangles_in;

layout(set = 0, binding = 1) buffer triangles_out_block
{
	uint       triangle_count;
    float[]    triangles_out;
};

void main()
{
    const ivec3 size = imageSize(triangles_in);
	triangle_count = 0;

	for (int z = 0; z < size.z; z++)
	{
		for (int y = 0; y < size.y; y++)
		{
			for (int x = 0; x < size.x; x += 45)
			{
				for (int t = 0; t < 45; t += 9)
				{
					vec3 p0 = vec3(
						imageLoad(triangles_in, ivec3(x + t    , y, z)).x,
						imageLoad(triangles_in, ivec3(x + t + 1, y, z)).x,
						imageLoad(triangles_in, ivec3(x + t + 2, y, z)).x
					);
					vec3 p1 = vec3(
						imageLoad(triangles_in, ivec3(x + t + 3, y, z)).x,
						imageLoad(triangles_in, ivec3(x + t + 4, y, z)).x,
						imageLoad(triangles_in, ivec3(x + t + 5, y, z)).x
					);
					vec3 p2 = vec3(
						imageLoad(triangles_in, ivec3(x + t + 6, y, z)).x,
						imageLoad(triangles_in, ivec3(x + t + 7, y, z)).x,
						imageLoad(triangles_in, ivec3(x + t + 8, y, z)).x
					);
					
					if (p0.x == 0.0 && p0.y == 0.0 && p0.z == 0.0 && p1.x == 0.0 && p1.y == 0.0 && p1.z == 0.0)
					{
						t = size.x;
					}
					else
					{
						triangles_out[9 * triangle_count    ] = p0.x;
						triangles_out[9 * triangle_count + 1] = p0.y;
						triangles_out[9 * triangle_count + 2] = p0.z;
						triangles_out[9 * triangle_count + 3] = p1.x;
						triangles_out[9 * triangle_count + 4] = p1.y;
						triangles_out[9 * triangle_count + 5] = p1.z;
						triangles_out[9 * triangle_count + 6] = p2.x;
						triangles_out[9 * triangle_count + 7] = p2.y;
						triangles_out[9 * triangle_count + 8] = p2.z;
						triangle_count++;
					}
				}
			}
		}
	}
}
