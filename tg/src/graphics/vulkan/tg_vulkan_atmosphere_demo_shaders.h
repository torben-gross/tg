/**
 * Copyright (c) 2017 Eric Bruneton
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef TG_VULKAN_ATMOSPHERE_DEMO_SHADERS_H
#define TG_VULKAN_ATMOSPHERE_DEMO_SHADERS_H

static const char p_atmosphere_demo_vertex_shader[] =
	"#version 450\r\n"
	"\r\n"
	"layout(location = 0) in vec2 vertex;\r\n"
	"\r\n"
	"layout(set = 0, binding = 4) uniform ubo\r\n"
	"{\r\n"
	"    mat4 model_from_view;\r\n"
	"    mat4 view_from_clip;\r\n"
	"};\r\n"
	"\r\n"
	"layout(location = 0) out vec3 view_ray;\r\n"
	"\r\n"
	"void main()\r\n"
	"{\r\n"
	"    vec4 vert = vec4(vertex.x, vertex.y, 0.0, 1.0);\r\n"
	"    view_ray = (model_from_view * vec4((view_from_clip * vert).xyz, 0.0)).xyz;\r\n"
	"    gl_Position = vert;\r\n"
	"}\r\n";

static const char p_atmosphere_demo_fragment_shader[] =
	"layout(location = 0) in vec3 view_ray;\r\n"
	"\r\n"
	"layout(set = 0, binding = 5) uniform ubo\r\n"
	"{\r\n"
	"    vec4 camera;\r\n"
	"    float exposure;\r\n"
	"    float pad0;\r\n"
	"    float pad1;\r\n"
	"    float pad2;\r\n"
	"    vec4 white_point;\r\n"
	"    vec4 earth_center;\r\n"
	"    vec4 sun_direction;\r\n"
	"    vec2 sun_size;\r\n"
	"};\r\n"
	"\r\n"
	"layout(location = 0) out vec4 color;\r\n"
	"\r\n"
	"const float PI = 3.14159265;\r\n"
	"const vec3 kSphereCenter = vec3(0.0, 0.0, 1000.0) / kLengthUnitInMeters;\r\n"
	"const float kSphereRadius = 1000.0 / kLengthUnitInMeters;\r\n"
	"const vec3 kSphereAlbedo = vec3(0.8);\r\n"
	"const vec3 kGroundAlbedo = vec3(0.0, 0.0, 0.04);\r\n"
	"\r\n"
	"#ifdef USE_LUMINANCE\r\n"
	"#define tg_get_solar_radiance tg_get_solar_luminance\r\n"
	"#define tg_get_sky_radiance tg_get_sky_luminance\r\n"
	"#define tg_get_sky_radiance_to_point tg_get_sky_luminance_to_point\r\n"
	"#define tg_get_sun_and_sky_irradiance tg_get_sun_and_sky_illuminance\r\n"
	"#endif\r\n"
	"\r\n"
	"vec3 tg_get_solar_radiance();\r\n"
	"vec3 tg_get_sky_radiance(vec3 camera, vec3 view_ray, float shadow_length, vec3 sun_direction, out vec3 transmittance);\r\n"
	"vec3 tg_get_sky_radiance_to_point(vec3 camera, vec3 point, float shadow_length, vec3 sun_direction, out vec3 transmittance);\r\n"
	"vec3 tg_get_sun_and_sky_irradiance(vec3 p, vec3 normal, vec3 sun_direction, out vec3 sky_irradiance);\r\n"
	"\r\n"
	"float tg_get_sun_visibility(vec3 point, vec3 sun_direction)\r\n"
	"{\r\n"
	"    vec3 p = point - kSphereCenter;\r\n"
	"    float p_dot_v = dot(p, sun_direction.xyz);\r\n"
	"    float p_dot_p = dot(p, p);\r\n"
	"    float ray_sphere_center_squared_distance = p_dot_p - p_dot_v * p_dot_v;\r\n"
	"    float distance_to_intersection = -p_dot_v - sqrt(kSphereRadius * kSphereRadius - ray_sphere_center_squared_distance);\r\n"
	"    if (distance_to_intersection > 0.0)\r\n"
	"    {\r\n"
	"        float ray_sphere_distance = kSphereRadius - sqrt(ray_sphere_center_squared_distance);\r\n"
	"        float ray_sphere_angular_distance = -ray_sphere_distance / p_dot_v;\r\n"
	"        return smoothstep(1.0, 0.0, ray_sphere_angular_distance / sun_size.x);\r\n"
	"    }\r\n"
	"    return 1.0;\r\n"
	"}\r\n"
	"\r\n"
	"float GetSkyVisibility(vec3 point)\r\n"
	"{\r\n"
	"    vec3 p = point - kSphereCenter;\r\n"
	"    float p_dot_p = dot(p, p);\r\n"
	"    return 1.0 + p.z / sqrt(p_dot_p) * kSphereRadius * kSphereRadius / p_dot_p;\r\n"
	"}\r\n"
	"\r\n"
	"void tg_get_sphere_shadow_in_out(vec3 view_direction, vec3 sun_direction, out float d_in, out float d_out)\r\n"
	"{\r\n"
	"    vec3 pos = camera.xyz - kSphereCenter;\r\n"
	"    float pos_dot_sun = dot(pos, sun_direction.xyz);\r\n"
	"    float view_dot_sun = dot(view_direction, sun_direction.xyz);\r\n"
	"    float k = sun_size.x;\r\n"
	"    float l = 1.0 + k * k;\r\n"
	"    float a = 1.0 - l * view_dot_sun * view_dot_sun;\r\n"
	"    float b = dot(pos, view_direction) - l * pos_dot_sun * view_dot_sun - k * kSphereRadius * view_dot_sun;\r\n"
	"    float c = dot(pos, pos) - l * pos_dot_sun * pos_dot_sun - 2.0 * k * kSphereRadius * pos_dot_sun - kSphereRadius * kSphereRadius;\r\n"
	"    float discriminant = b * b - a * c;\r\n"
	"    if (discriminant > 0.0)\r\n"
	"    {\r\n"
	"        d_in = max(0.0, (-b - sqrt(discriminant)) / a);\r\n"
	"        d_out = (-b + sqrt(discriminant)) / a;\r\n"
	"        float d_base = -pos_dot_sun / view_dot_sun;\r\n"
	"        float d_apex = -(pos_dot_sun + kSphereRadius / k) / view_dot_sun;\r\n"
	"        if (view_dot_sun > 0.0) {\r\n"
	"            d_in = max(d_in, d_apex);\r\n"
	"            d_out = a > 0.0 ? min(d_out, d_base) : d_base;\r\n"
	"        } else {\r\n"
	"            d_in = a > 0.0 ? max(d_in, d_base) : d_base;\r\n"
	"            d_out = min(d_out, d_apex);\r\n"
	"        }\r\n"
	"    }\r\n"
	"    else\r\n"
	"    {\r\n"
	"        d_in = 0.0;\r\n"
	"        d_out = 0.0;\r\n"
	"    }\r\n"
	"}\r\n"
	"\r\n"
	"void main()\r\n"
	"{\r\n"
	"    vec3 view_direction = normalize(view_ray);\r\n"
	"    float fragment_angular_size = length(dFdx(view_ray) + dFdy(view_ray)) / length(view_ray);\r\n"
	"    float shadow_in;\r\n"
	"    float shadow_out;\r\n"
	"    tg_get_sphere_shadow_in_out(view_direction, sun_direction.xyz, shadow_in, shadow_out);\r\n"
	"    float lightshaft_fadein_hack = smoothstep(0.02, 0.04, dot(normalize(camera.xyz - earth_center.xyz), sun_direction.xyz));\r\n"
	"    vec3 p = camera.xyz - kSphereCenter;\r\n"
	"    float p_dot_v = dot(p, view_direction);\r\n"
	"    float p_dot_p = dot(p, p);\r\n"
	"    float ray_sphere_center_squared_distance = p_dot_p - p_dot_v * p_dot_v;\r\n"
	"    float distance_to_intersection = -p_dot_v - sqrt(kSphereRadius * kSphereRadius - ray_sphere_center_squared_distance);\r\n"
	"    float sphere_alpha = 0.0;\r\n"
	"    vec3 sphere_radiance = vec3(0.0);\r\n"
	"    if (distance_to_intersection > 0.0)\r\n"
	"    {\r\n"
	"        float ray_sphere_distance = kSphereRadius - sqrt(ray_sphere_center_squared_distance);\r\n"
	"        float ray_sphere_angular_distance = -ray_sphere_distance / p_dot_v;\r\n"
	"        sphere_alpha = min(ray_sphere_angular_distance / fragment_angular_size, 1.0);\r\n"
	"        vec3 point = camera.xyz + view_direction * distance_to_intersection;\r\n"
	"        vec3 normal = normalize(point - kSphereCenter);\r\n"
	"        vec3 sky_irradiance;\r\n"
	"        vec3 sun_irradiance = tg_get_sun_and_sky_irradiance(point - earth_center.xyz, normal, sun_direction.xyz, sky_irradiance);\r\n"
	"        sphere_radiance = kSphereAlbedo * (1.0 / PI) * (sun_irradiance + sky_irradiance);\r\n"
	"        float shadow_length =\r\n"
	"            max(0.0, min(shadow_out, distance_to_intersection) - shadow_in)\r\n"
	"            * lightshaft_fadein_hack;\r\n"
	"        vec3 transmittance;\r\n"
	"        vec3 in_scatter = tg_get_sky_radiance_to_point(camera.xyz - earth_center.xyz, point - earth_center.xyz, shadow_length, sun_direction.xyz, transmittance);\r\n"
	"        sphere_radiance = sphere_radiance * transmittance + in_scatter;\r\n"
	"    }\r\n"
	"    p = camera.xyz - earth_center.xyz;\r\n"
	"    p_dot_v = dot(p, view_direction);\r\n"
	"    p_dot_p = dot(p, p);\r\n"
	"    float ray_earth_center_squared_distance = p_dot_p - p_dot_v * p_dot_v;\r\n"
	"    distance_to_intersection = -p_dot_v - sqrt(earth_center.z * earth_center.z - ray_earth_center_squared_distance);\r\n"
	"    float ground_alpha = 0.0;\r\n"
	"    vec3 ground_radiance = vec3(0.0);\r\n"
	"    if (distance_to_intersection > 0.0)\r\n"
	"    {\r\n"
	"        vec3 point = camera.xyz + view_direction * distance_to_intersection;\r\n"
	"        vec3 normal = normalize(point - earth_center.xyz);\r\n"
	"        vec3 sky_irradiance;\r\n"
	"        vec3 sun_irradiance = tg_get_sun_and_sky_irradiance(point - earth_center.xyz, normal, sun_direction.xyz, sky_irradiance);\r\n"
	"        ground_radiance = kGroundAlbedo * (1.0 / PI)\r\n"
	"            * (sun_irradiance * tg_get_sun_visibility(point, sun_direction.xyz)\r\n"
	"            + sky_irradiance * GetSkyVisibility(point));\r\n"
	"        float shadow_length =\r\n"
	"            max(0.0, min(shadow_out, distance_to_intersection) - shadow_in)\r\n"
	"            * lightshaft_fadein_hack;\r\n"
	"        vec3 transmittance;\r\n"
	"        vec3 in_scatter = tg_get_sky_radiance_to_point(camera.xyz - earth_center.xyz, point - earth_center.xyz, shadow_length, sun_direction.xyz, transmittance);\r\n"
	"        ground_radiance = ground_radiance * transmittance + in_scatter;\r\n"
	"        ground_alpha = 1.0;\r\n"
	"    }\r\n"
	"    float shadow_length = max(0.0, shadow_out - shadow_in) * lightshaft_fadein_hack;\r\n"
	"    vec3 transmittance;\r\n"
	"    vec3 radiance = tg_get_sky_radiance(\r\n"
	"        camera.xyz - earth_center.xyz,\r\n"
	"        view_direction,\r\n"
	"        shadow_length,\r\n"
	"        sun_direction.xyz,\r\n"
	"        transmittance\r\n"
	"    );\r\n"
	"    if (dot(view_direction, sun_direction.xyz) > sun_size.y)\r\n"
	"    {\r\n"
	"        radiance = radiance + transmittance * tg_get_solar_radiance();\r\n"
	"    }\r\n"
	"    radiance = mix(radiance, ground_radiance, ground_alpha);\r\n"
	"    radiance = mix(radiance, sphere_radiance, sphere_alpha);\r\n"
	"    color.rgb = pow(vec3(1.0) - exp(-radiance / white_point.xyz * exposure), vec3(1.0 / 2.2));\r\n"
	"    color.a = 1.0;\r\n"
	"}\r\n";

#endif
