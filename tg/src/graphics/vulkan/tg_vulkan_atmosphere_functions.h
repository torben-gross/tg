/**
 * Copyright (c) 2017 Eric Bruneton
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. TG_IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER TG_IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING TG_IN ANY WAY TG_OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Precomputed Atmospheric Scattering
 * Copyright (c) 2008 INRIA
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. TG_IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER TG_IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING TG_IN ANY WAY TG_OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef TG_VULKAN_ATMOSPHERE_FUNCTIONS_H
#define TG_VULKAN_ATMOSPHERE_FUNCTIONS_H

static const char TG_FUNCTIONS[] =
"tg_number tg_clamp_cosine(tg_number mu)\r\n"
"{\r\n"
"    return clamp(mu, tg_number(-1.0), tg_number(1.0));\r\n"
"}\r\n"
"\r\n"
"tg_length tg_clamp_distance(tg_length d)\r\n"
"{\r\n"
"    return max(d, 0.0 * m);\r\n"
"}\r\n"
"\r\n"
"tg_length tg_clamp_radius(TG_IN(tg_atmosphere_parameters) atmosphere, tg_length r)\r\n"
"{\r\n"
"    return clamp(r, atmosphere.bottom_radius, atmosphere.top_radius);\r\n"
"}\r\n"
"\r\n"
"tg_length tg_safe_sqrt(tg_area a)\r\n"
"{\r\n"
"    return sqrt(max(a, 0.0 * m2));\r\n"
"}\r\n"
"\r\n"
"tg_length tg_distance_to_top_atmosphere_boundary(TG_IN(tg_atmosphere_parameters) atmosphere, tg_length r, tg_number mu)\r\n"
"{\r\n"
"    TG_ASSERT(r <= atmosphere.top_radius);\r\n"
"    TG_ASSERT(mu >= -1.0 && mu <= 1.0);\r\n"
"    \r\n"
"    tg_area discriminant = r * r * (mu * mu - 1.0) + atmosphere.top_radius * atmosphere.top_radius;\r\n"
"    return tg_clamp_distance(-r * mu + tg_safe_sqrt(discriminant));\r\n"
"}\r\n"
"\r\n"
"tg_length tg_distance_to_bottom_atmosphere_boundary(TG_IN(tg_atmosphere_parameters) atmosphere, tg_length r, tg_number mu)\r\n"
"{\r\n"
"    TG_ASSERT(r >= atmosphere.bottom_radius);\r\n"
"    TG_ASSERT(mu >= -1.0 && mu <= 1.0);\r\n"
"    \r\n"
"    tg_area discriminant = r * r * (mu * mu - 1.0) + atmosphere.bottom_radius * atmosphere.bottom_radius;\r\n"
"    return tg_clamp_distance(-r * mu - tg_safe_sqrt(discriminant));\r\n"
"}\r\n"
"\r\n"
"bool tg_ray_intersects_ground(TG_IN(tg_atmosphere_parameters) atmosphere, tg_length r, tg_length mu)\r\n"
"{\r\n"
"    TG_ASSERT(r >= atmosphere.bottom_radius);\r\n"
"    TG_ASSERT(mu >= -1.0 && mu <= 1.0);\r\n"
"    \r\n"
"    return mu < 0.0 && r * r * (mu * mu - 1.0) + atmosphere.bottom_radius * atmosphere.bottom_radius >= 0.0 * m2;\r\n"
"}\r\n"
"\r\n"
"tg_number tg_get_layer_density(TG_IN(tg_density_profile_layer) layer, tg_length altitude) {\r\n"
"    tg_number density = layer.exp_term * exp(layer.exp_scale * altitude) + layer.linear_term * altitude + layer.constant_term;\r\n"
"    return clamp(density, tg_number(0.0), tg_number(1.0));\r\n"
"}\r\n"
"\r\n"
"tg_number tg_get_profile_density(TG_IN(tg_density_profile) profile, tg_length altitude)\r\n"
"{\r\n"
"    return altitude < profile.layers[0].width ?\r\n"
"        tg_get_layer_density(profile.layers[0], altitude) :\r\n"
"        tg_get_layer_density(profile.layers[1], altitude);\r\n"
"}\r\n"
"\r\n"
"tg_length tg_compute_optical_length_to_top_atmosphere_boundary(TG_IN(tg_atmosphere_parameters) atmosphere, TG_IN(tg_density_profile) profile, tg_length r, tg_number mu)\r\n"
"{\r\n"
"    TG_ASSERT(r >= atmosphere.bottom_radius && r <= atmosphere.top_radius);\r\n"
"    TG_ASSERT(mu >= -1.0 && mu <= 1.0);\r\n"
"    \r\n"
"    const int TG_SAMPLE_COUNT = 500;\r\n"
"    tg_length dx = tg_distance_to_top_atmosphere_boundary(atmosphere, r, mu) / tg_number(TG_SAMPLE_COUNT);\r\n"
"    tg_length result = 0.0 * m;\r\n"
"    \r\n"
"    for (int i = 0; i <= TG_SAMPLE_COUNT; ++i)\r\n"
"    {\r\n"
"        tg_length d_i = tg_number(i) * dx;\r\n"
"        tg_length r_i = sqrt(d_i * d_i + 2.0 * r * mu * d_i + r * r);\r\n"
"        tg_number y_i = tg_get_profile_density(profile, r_i - atmosphere.bottom_radius);\r\n"
"        tg_number weight_i = i == 0 || i == TG_SAMPLE_COUNT ? 0.5 : 1.0;\r\n"
"        result += y_i * weight_i * dx;\r\n"
"    }\r\n"
"    \r\n"
"    return result;\r\n"
"}\r\n"
"\r\n"
"tg_dimensionless_spectrum tg_compute_transmittance_top_to_atmosphere_boundary(TG_IN(tg_atmosphere_parameters) atmosphere, tg_length r, tg_number mu)\r\n"
"{\r\n"
"    TG_ASSERT(r >= atmosphere.bottom_radius && r <= atmosphere.top_radius);\r\n"
"    TG_ASSERT(mu >= -1.0 && mu <= 1.0);\r\n"
"    \r\n"
"    return exp(-(\r\n"
"        atmosphere.rayleigh_scattering *\r\n"
"            tg_compute_optical_length_to_top_atmosphere_boundary(atmosphere, atmosphere.rayleigh_density, r, mu) +\r\n"
"        atmosphere.mie_extinction *\r\n"
"            tg_compute_optical_length_to_top_atmosphere_boundary(atmosphere, atmosphere.mie_density, r, mu) +\r\n"
"        atmosphere.absorption_extinction *\r\n"
"            tg_compute_optical_length_to_top_atmosphere_boundary(atmosphere, atmosphere.absorption_density, r, mu)\r\n"
"        )\r\n"
"    );\r\n"
"}\r\n"
"\r\n"
"tg_number tg_get_texture_coord_from_unit_range(tg_number x, int texture_size)\r\n"
"{\r\n"
"    return 0.5 / tg_number(texture_size) + x * (1.0 - 1.0 / tg_number(texture_size));\r\n"
"}\r\n"
"\r\n"
"tg_number tg_get_unit_range_from_texture_coord(tg_number u, int texture_size)\r\n"
"{\r\n"
"    return (u - 0.5 / tg_number(texture_size)) / (1.0 - 1.0 / tg_number(texture_size));\r\n"
"}\r\n"
"\r\n"
"vec2 tg_get_transmittance_texture_uv_from_r_mu(TG_IN(tg_atmosphere_parameters) atmosphere, tg_length r, tg_number mu)\r\n"
"{\r\n"
"    TG_ASSERT(r >= atmosphere.bottom_radius && r <= atmosphere.top_radius);\r\n"
"    TG_ASSERT(mu >= -1.0 && mu <= 1.0);\r\n"
"    \r\n"
"    tg_length H = sqrt(atmosphere.top_radius * atmosphere.top_radius - atmosphere.bottom_radius * atmosphere.bottom_radius);\r\n"
"    tg_length rho = tg_safe_sqrt(r * r - atmosphere.bottom_radius * atmosphere.bottom_radius);\r\n"
"    tg_length d = tg_distance_to_top_atmosphere_boundary(atmosphere, r, mu);\r\n"
"    tg_length d_min = atmosphere.top_radius - r;\r\n"
"    tg_length d_max = rho + H;\r\n"
"    tg_number x_mu = (d - d_min) / (d_max - d_min);\r\n"
"    tg_number x_r = rho / H;\r\n"
"    return vec2(\r\n"
"        tg_get_texture_coord_from_unit_range(x_mu, TG_TRANSMITTANCE_TEXTURE_WIDTH),\r\n"
"        tg_get_texture_coord_from_unit_range(x_r, TG_TRANSMITTANCE_TEXTURE_HEIGHT)\r\n"
"    );\r\n"
"}\r\n"
"\r\n"
"void tg_get_r_mu_from_transmittance_texture_uv(TG_IN(tg_atmosphere_parameters) atmosphere, TG_IN(vec2) uv, TG_OUT(tg_length) r, TG_OUT(tg_number) mu)\r\n"
"{\r\n"
"    TG_ASSERT(uv.x >= 0.0 && uv.x <= 1.0);\r\n"
"    TG_ASSERT(uv.y >= 0.0 && uv.y <= 1.0);\r\n"
"    \r\n"
"    tg_number x_mu = tg_get_unit_range_from_texture_coord(uv.x, TG_TRANSMITTANCE_TEXTURE_WIDTH);\r\n"
"    tg_number x_r = tg_get_unit_range_from_texture_coord(uv.y, TG_TRANSMITTANCE_TEXTURE_HEIGHT);\r\n"
"    tg_length H = sqrt(atmosphere.top_radius * atmosphere.top_radius - atmosphere.bottom_radius * atmosphere.bottom_radius);\r\n"
"    tg_length rho = H * x_r;\r\n"
"    r = sqrt(rho * rho + atmosphere.bottom_radius * atmosphere.bottom_radius);\r\n"
"    tg_length d_min = atmosphere.top_radius - r;\r\n"
"    tg_length d_max = rho + H;\r\n"
"    tg_length d = d_min + x_mu * (d_max - d_min);\r\n"
"    mu = d == 0.0 * m ? tg_number(1.0) : (H * H - rho * rho - d * d) / (2.0 * r * d);\r\n"
"    mu = tg_clamp_cosine(mu);\r\n"
"}\r\n"
"\r\n"
"tg_dimensionless_spectrum tg_compute_transmittance_to_top_atmosphere_boundary_texture(TG_IN(tg_atmosphere_parameters) atmosphere, TG_IN(vec2) frag_coord)\r\n"
"{\r\n"
"    const vec2 TG_TRANSMITTANCE_TEXTURE_SIZE = vec2(TG_TRANSMITTANCE_TEXTURE_WIDTH, TG_TRANSMITTANCE_TEXTURE_HEIGHT);\r\n"
"    tg_length r;\r\n"
"    tg_number mu;\r\n"
"    tg_get_r_mu_from_transmittance_texture_uv(atmosphere, frag_coord / TG_TRANSMITTANCE_TEXTURE_SIZE, r, mu);\r\n"
"    return tg_compute_transmittance_top_to_atmosphere_boundary(atmosphere, r, mu);\r\n"
"}\r\n"
"\r\n"
"tg_dimensionless_spectrum tg_get_transmittance_to_top_atmosphere_boundary(TG_IN(tg_atmosphere_parameters) atmosphere, TG_IN(tg_transmittance_texture) transmittance_texture, tg_length r, tg_number mu)\r\n"
"{\r\n"
"    TG_ASSERT(r >= atmosphere.bottom_radius && r <= atmosphere.top_radius);\r\n"
"    \r\n"
"    vec2 uv = tg_get_transmittance_texture_uv_from_r_mu(atmosphere, r, mu);\r\n"
"    return tg_dimensionless_spectrum(texture(transmittance_texture, uv));\r\n"
"}\r\n"
"\r\n"
"tg_dimensionless_spectrum tg_get_transmittance(TG_IN(tg_atmosphere_parameters) atmosphere, TG_IN(tg_transmittance_texture) transmittance_texture, tg_length r, tg_number mu, tg_length d, bool ray_r_mu_intersects_ground)\r\n"
"{\r\n"
"    TG_ASSERT(r >= atmosphere.bottom_radius && r <= atmosphere.top_radius);\r\n"
"    TG_ASSERT(mu >= -1.0 && mu <= 1.0);\r\n"
"    TG_ASSERT(d >= 0.0 * m);\r\n"
"    \r\n"
"    tg_length r_d = tg_clamp_radius(atmosphere, sqrt(d * d + 2.0 * r * mu * d + r * r));\r\n"
"    tg_number mu_d = tg_clamp_cosine((r * mu + d) / r_d);\r\n"
"    \r\n"
"    if (ray_r_mu_intersects_ground)\r\n"
"    {\r\n"
"      return min(\r\n"
"          tg_get_transmittance_to_top_atmosphere_boundary(\r\n"
"              atmosphere, transmittance_texture, r_d, -mu_d) /\r\n"
"          tg_get_transmittance_to_top_atmosphere_boundary(\r\n"
"              atmosphere, transmittance_texture, r, -mu),\r\n"
"          tg_dimensionless_spectrum(1.0));\r\n"
"    }\r\n"
"    else\r\n"
"    {\r\n"
"      return min(\r\n"
"          tg_get_transmittance_to_top_atmosphere_boundary(\r\n"
"              atmosphere, transmittance_texture, r, mu) /\r\n"
"          tg_get_transmittance_to_top_atmosphere_boundary(\r\n"
"              atmosphere, transmittance_texture, r_d, mu_d),\r\n"
"          tg_dimensionless_spectrum(1.0));\r\n"
"    }\r\n"
"}\r\n"
"\r\n"
"tg_dimensionless_spectrum tg_get_transmittance_to_sun(TG_IN(tg_atmosphere_parameters) atmosphere, TG_IN(tg_transmittance_texture) transmittance_texture, tg_length r, tg_number mu_s)\r\n"
"{\r\n"
"    tg_number sin_theta_h = atmosphere.bottom_radius / r;\r\n"
"    tg_number cos_theta_h = -sqrt(max(1.0 - sin_theta_h * sin_theta_h, 0.0));\r\n"
"    return tg_get_transmittance_to_top_atmosphere_boundary(\r\n"
"        atmosphere, transmittance_texture, r, mu_s) *\r\n"
"        smoothstep(-sin_theta_h * atmosphere.sun_angular_radius / rad, sin_theta_h * atmosphere.sun_angular_radius / rad, mu_s - cos_theta_h\r\n"
"    );\r\n"
"}\r\n"
"\r\n"
"void tg_compute_single_scattering_integrand(\r\n"
"    TG_IN(tg_atmosphere_parameters)      atmosphere,\r\n"
"    TG_IN(tg_transmittance_texture)      transmittance_texture,\r\n"
"    tg_length                            r,\r\n"
"    tg_number                            mu,\r\n"
"    tg_number                            mu_s,\r\n"
"    tg_number                            nu,\r\n"
"    tg_length                            d,\r\n"
"    bool                                 ray_r_mu_intersects_ground,\r\n"
"    TG_OUT(tg_dimensionless_spectrum)    rayleigh,\r\n"
"    TG_OUT(tg_dimensionless_spectrum)    mie\r\n"
")\r\n"
"{\r\n"
"    tg_length r_d = tg_clamp_radius(atmosphere, sqrt(d * d + 2.0 * r * mu * d + r * r));\r\n"
"    tg_number mu_s_d = tg_clamp_cosine((r * mu_s + d * nu) / r_d);\r\n"
"    tg_dimensionless_spectrum transmittance =\r\n"
"        tg_get_transmittance(\r\n"
"            atmosphere, transmittance_texture, r, mu, d,\r\n"
"            ray_r_mu_intersects_ground) *\r\n"
"        tg_get_transmittance_to_sun(\r\n"
"            atmosphere, transmittance_texture, r_d, mu_s_d);\r\n"
"    rayleigh = transmittance * tg_get_profile_density(atmosphere.rayleigh_density, r_d - atmosphere.bottom_radius);\r\n"
"    mie = transmittance * tg_get_profile_density(atmosphere.mie_density, r_d - atmosphere.bottom_radius);\r\n"
"}\r\n"
"\r\n"
"tg_length tg_distance_to_nearest_atmosphere_boundary(TG_IN(tg_atmosphere_parameters) atmosphere, tg_length r, tg_number mu, bool ray_r_mu_intersects_ground)\r\n"
"{\r\n"
"    if (ray_r_mu_intersects_ground)\r\n"
"    {\r\n"
"      return tg_distance_to_bottom_atmosphere_boundary(atmosphere, r, mu);\r\n"
"    }\r\n"
"    else\r\n"
"    {\r\n"
"      return tg_distance_to_top_atmosphere_boundary(atmosphere, r, mu);\r\n"
"    }\r\n"
"}\r\n"
"\r\n"
"void tg_compute_single_scattering(\r\n"
"    TG_IN(tg_atmosphere_parameters)    atmosphere,\r\n"
"    TG_IN(tg_transmittance_texture)    transmittance_texture,\r\n"
"    tg_length                          r,\r\n"
"    tg_number                          mu,\r\n"
"    tg_number                          mu_s,\r\n"
"    tg_number                          nu,\r\n"
"    bool                               ray_r_mu_intersects_ground,\r\n"
"    TG_OUT(tg_irradiance_spectrum)     rayleigh,\r\n"
"    TG_OUT(tg_irradiance_spectrum)     mie\r\n"
")\r\n"
"{\r\n"
"    TG_ASSERT(r >= atmosphere.bottom_radius && r <= atmosphere.top_radius);\r\n"
"    TG_ASSERT(mu >= -1.0 && mu <= 1.0);\r\n"
"    TG_ASSERT(mu_s >= -1.0 && mu_s <= 1.0);\r\n"
"    TG_ASSERT(nu >= -1.0 && nu <= 1.0);\r\n"
"    \r\n"
"    const int TG_SAMPLE_COUNT = 50;\r\n"
"    tg_length dx = tg_distance_to_nearest_atmosphere_boundary(atmosphere, r, mu, ray_r_mu_intersects_ground) / tg_number(TG_SAMPLE_COUNT);\r\n"
"    tg_dimensionless_spectrum rayleigh_sum = tg_dimensionless_spectrum(0.0);\r\n"
"    tg_dimensionless_spectrum mie_sum = tg_dimensionless_spectrum(0.0);\r\n"
"    for (int i = 0; i <= TG_SAMPLE_COUNT; ++i)\r\n"
"    {\r\n"
"      tg_length d_i = tg_number(i) * dx;\r\n"
"      tg_dimensionless_spectrum rayleigh_i;\r\n"
"      tg_dimensionless_spectrum mie_i;\r\n"
"      tg_compute_single_scattering_integrand(atmosphere, transmittance_texture, r, mu, mu_s, nu, d_i, ray_r_mu_intersects_ground, rayleigh_i, mie_i);\r\n"
"      tg_number weight_i = (i == 0 || i == TG_SAMPLE_COUNT) ? 0.5 : 1.0;\r\n"
"      rayleigh_sum += rayleigh_i * weight_i;\r\n"
"      mie_sum += mie_i * weight_i;\r\n"
"    }\r\n"
"    rayleigh = rayleigh_sum * dx * atmosphere.solar_irradiance * atmosphere.rayleigh_scattering;\r\n"
"    mie = mie_sum * dx * atmosphere.solar_irradiance * atmosphere.mie_scattering;\r\n"
"}\r\n"
"\r\n"
"tg_inverse_solid_angle tg_rayleigh_phase_function(tg_number nu)\r\n"
"{\r\n"
"    tg_inverse_solid_angle k = 3.0 / (16.0 * TG_PI * sr);\r\n"
"    return k * (1.0 + nu * nu);\r\n"
"}\r\n"
"\r\n"
"tg_inverse_solid_angle tg_mie_phase_function(tg_number g, tg_number nu)\r\n"
"{\r\n"
"    tg_inverse_solid_angle k = 3.0 / (8.0 * TG_PI * sr) * (1.0 - g * g) / (2.0 + g * g);\r\n"
"    return k * (1.0 + nu * nu) / pow(1.0 + g * g - 2.0 * g * nu, 1.5);\r\n"
"}\r\n"
"\r\n"
"vec4 tg_get_scattering_texture_uvwz_from_r_mu_mu_s_nu(TG_IN(tg_atmosphere_parameters) atmosphere, tg_length r, tg_number mu, tg_number mu_s, tg_number nu, bool ray_r_mu_intersects_ground)\r\n"
"{\r\n"
"    TG_ASSERT(r >= atmosphere.bottom_radius && r <= atmosphere.top_radius);\r\n"
"    TG_ASSERT(mu >= -1.0 && mu <= 1.0);\r\n"
"    TG_ASSERT(mu_s >= -1.0 && mu_s <= 1.0);\r\n"
"    TG_ASSERT(nu >= -1.0 && nu <= 1.0);\r\n"
"    \r\n"
"    tg_length H = sqrt(atmosphere.top_radius * atmosphere.top_radius - atmosphere.bottom_radius * atmosphere.bottom_radius);\r\n"
"    tg_length rho = tg_safe_sqrt(r * r - atmosphere.bottom_radius * atmosphere.bottom_radius);\r\n"
"    tg_number u_r = tg_get_texture_coord_from_unit_range(rho / H, TG_SCATTERING_TEXTURE_R_SIZE);\r\n"
"    \r\n"
"    tg_length r_mu = r * mu;\r\n"
"    tg_area discriminant = r_mu * r_mu - r * r + atmosphere.bottom_radius * atmosphere.bottom_radius;\r\n"
"    tg_number u_mu;\r\n"
"    if (ray_r_mu_intersects_ground)\r\n"
"    {\r\n"
"        tg_length d = -r_mu - tg_safe_sqrt(discriminant);\r\n"
"        tg_length d_min = r - atmosphere.bottom_radius;\r\n"
"        tg_length d_max = rho;\r\n"
"        u_mu = 0.5 - 0.5 * tg_get_texture_coord_from_unit_range(d_max == d_min ? 0.0 : (d - d_min) / (d_max - d_min), TG_SCATTERING_TEXTURE_MU_SIZE / 2);\r\n"
"    }\r\n"
"    else\r\n"
"    {\r\n"
"        tg_length d = -r_mu + tg_safe_sqrt(discriminant + H * H);\r\n"
"        tg_length d_min = atmosphere.top_radius - r;\r\n"
"        tg_length d_max = rho + H;\r\n"
"        u_mu = 0.5 + 0.5 * tg_get_texture_coord_from_unit_range((d - d_min) / (d_max - d_min), TG_SCATTERING_TEXTURE_MU_SIZE / 2);\r\n"
"    }\r\n"
"    \r\n"
"    tg_length d = tg_distance_to_top_atmosphere_boundary(atmosphere, atmosphere.bottom_radius, mu_s);\r\n"
"    tg_length d_min = atmosphere.top_radius - atmosphere.bottom_radius;\r\n"
"    tg_length d_max = H;\r\n"
"    tg_number a = (d - d_min) / (d_max - d_min);\r\n"
"    tg_number A = -2.0 * atmosphere.mu_s_min * atmosphere.bottom_radius / (d_max - d_min);\r\n"
"    tg_number u_mu_s = tg_get_texture_coord_from_unit_range(max(1.0 - a / A, 0.0) / (1.0 + a), TG_SCATTERING_TEXTURE_MU_S_SIZE);\r\n"
"    \r\n"
"    tg_number u_nu = (nu + 1.0) / 2.0;\r\n"
"    return vec4(u_nu, u_mu_s, u_mu, u_r);\r\n"
"}\r\n"
"\r\n"
"void tg_get_r_mu_mu_s_nu_from_scattering_texture_uvwz(\r\n"
"    TG_IN(tg_atmosphere_parameters)    atmosphere,\r\n"
"    TG_IN(vec4)                        uvwz,\r\n"
"    TG_OUT(tg_length)                  r,\r\n"
"    TG_OUT(tg_number)                  mu,\r\n"
"    TG_OUT(tg_number)                  mu_s,\r\n"
"    TG_OUT(tg_number)                  nu,\r\n"
"    TG_OUT(bool)                       ray_r_mu_intersects_ground\r\n"
")\r\n"
"{\r\n"
"    TG_ASSERT(uvwz.x >= 0.0 && uvwz.x <= 1.0);\r\n"
"    TG_ASSERT(uvwz.y >= 0.0 && uvwz.y <= 1.0);\r\n"
"    TG_ASSERT(uvwz.z >= 0.0 && uvwz.z <= 1.0);\r\n"
"    TG_ASSERT(uvwz.w >= 0.0 && uvwz.w <= 1.0);\r\n"
"    \r\n"
"    tg_length H = sqrt(atmosphere.top_radius * atmosphere.top_radius - atmosphere.bottom_radius * atmosphere.bottom_radius);\r\n"
"    tg_length rho = H * tg_get_unit_range_from_texture_coord(uvwz.w, TG_SCATTERING_TEXTURE_R_SIZE);\r\n"
"    r = sqrt(rho * rho + atmosphere.bottom_radius * atmosphere.bottom_radius);\r\n"
"    \r\n"
"    if (uvwz.z < 0.5)\r\n"
"    {\r\n"
"        tg_length d_min = r - atmosphere.bottom_radius;\r\n"
"        tg_length d_max = rho;\r\n"
"        tg_length d = d_min + (d_max - d_min) * tg_get_unit_range_from_texture_coord(1.0 - 2.0 * uvwz.z, TG_SCATTERING_TEXTURE_MU_SIZE / 2);\r\n"
"        mu = d == 0.0 * m ? tg_number(-1.0) : tg_clamp_cosine(-(rho * rho + d * d) / (2.0 * r * d));\r\n"
"        ray_r_mu_intersects_ground = true;\r\n"
"    }\r\n"
"    else\r\n"
"    {\r\n"
"        tg_length d_min = atmosphere.top_radius - r;\r\n"
"        tg_length d_max = rho + H;\r\n"
"        tg_length d = d_min + (d_max - d_min) * tg_get_unit_range_from_texture_coord(2.0 * uvwz.z - 1.0, TG_SCATTERING_TEXTURE_MU_SIZE / 2);\r\n"
"        mu = d == 0.0 * m ? tg_number(1.0) : tg_clamp_cosine((H * H - rho * rho - d * d) / (2.0 * r * d));\r\n"
"        ray_r_mu_intersects_ground = false;\r\n"
"    }\r\n"
"    \r\n"
"    tg_number x_mu_s = tg_get_unit_range_from_texture_coord(uvwz.y, TG_SCATTERING_TEXTURE_MU_S_SIZE);\r\n"
"    tg_length d_min = atmosphere.top_radius - atmosphere.bottom_radius;\r\n"
"    tg_length d_max = H;\r\n"
"    tg_number A = -2.0 * atmosphere.mu_s_min * atmosphere.bottom_radius / (d_max - d_min);\r\n"
"    tg_number a = (A - x_mu_s * A) / (1.0 + x_mu_s * A);\r\n"
"    tg_length d = d_min + min(a, A) * (d_max - d_min);\r\n"
"    mu_s = d == 0.0 * m ? tg_number(1.0) : tg_clamp_cosine((H * H - d * d) / (2.0 * atmosphere.bottom_radius * d));\r\n"
"    \r\n"
"    nu = tg_clamp_cosine(uvwz.x * 2.0 - 1.0);\r\n"
"}\r\n"
"\r\n"
"void tg_get_r_mu_mu_s_nu_from_scattering_texture_frag_coord(\r\n"
"    TG_IN(tg_atmosphere_parameters)    atmosphere,\r\n"
"    TG_IN(vec3)                        frag_coord,\r\n"
"    TG_OUT(tg_length)                  r,\r\n"
"    TG_OUT(tg_number)                  mu,\r\n"
"    TG_OUT(tg_number)                  mu_s,\r\n"
"    TG_OUT(tg_number)                  nu,\r\n"
"    TG_OUT(bool)                       ray_r_mu_intersects_ground\r\n"
")\r\n"
"{\r\n"
"    const vec4 SCATTERING_TEXTURE_SIZE = vec4(\r\n"
"        TG_SCATTERING_TEXTURE_NU_SIZE - 1,\r\n"
"        TG_SCATTERING_TEXTURE_MU_S_SIZE,\r\n"
"        TG_SCATTERING_TEXTURE_MU_SIZE,\r\n"
"        TG_SCATTERING_TEXTURE_R_SIZE\r\n"
"    );\r\n"
"    tg_number frag_coord_nu = floor(frag_coord.x / tg_number(TG_SCATTERING_TEXTURE_MU_S_SIZE));\r\n"
"    tg_number frag_coord_mu_s = mod(frag_coord.x, tg_number(TG_SCATTERING_TEXTURE_MU_S_SIZE));\r\n"
"    vec4 uvwz = vec4(frag_coord_nu, frag_coord_mu_s, frag_coord.y, frag_coord.z) / SCATTERING_TEXTURE_SIZE;\r\n"
"    tg_get_r_mu_mu_s_nu_from_scattering_texture_uvwz(atmosphere, uvwz, r, mu, mu_s, nu, ray_r_mu_intersects_ground);\r\n"
"    nu = clamp(nu, mu * mu_s - sqrt((1.0 - mu * mu) * (1.0 - mu_s * mu_s)), mu * mu_s + sqrt((1.0 - mu * mu) * (1.0 - mu_s * mu_s)));\r\n"
"}\r\n"
"\r\n"
"void tg_compute_single_scattering_texture(\r\n"
"    TG_IN(tg_atmosphere_parameters)    atmosphere,\r\n"
"    TG_IN(tg_transmittance_texture)    transmittance_texture,\r\n"
"    TG_IN(vec3)                        frag_coord,\r\n"
"    TG_OUT(tg_irradiance_spectrum)     rayleigh,\r\n"
"    TG_OUT(tg_irradiance_spectrum)     mie\r\n"
")\r\n"
"{\r\n"
"   tg_length r;\r\n"
"   tg_number mu;\r\n"
"   tg_number mu_s;\r\n"
"   tg_number nu;\r\n"
"   bool ray_r_mu_intersects_ground;\r\n"
"   tg_get_r_mu_mu_s_nu_from_scattering_texture_frag_coord(atmosphere, frag_coord, r, mu, mu_s, nu, ray_r_mu_intersects_ground);\r\n"
"   tg_compute_single_scattering(atmosphere, transmittance_texture, r, mu, mu_s, nu, ray_r_mu_intersects_ground, rayleigh, mie);\r\n"
"}\r\n"
"\r\n"
"TG_TEMPLATE(tg_abstract_spectrum)\r\n"
"tg_abstract_spectrum tg_get_scattering(\r\n"
"    TG_IN(tg_atmosphere_parameters)                                                  atmosphere,\r\n"
"    TG_IN(tg_abstract_scattering_texture TG_TEMPLATE_ARGUMENT(tg_abstract_spectrum))    scattering_texture,\r\n"
"    tg_length                                                                        r,\r\n"
"    tg_number                                                                        mu,\r\n"
"    tg_number                                                                        mu_s,\r\n"
"    tg_number                                                                        nu,\r\n"
"    bool                                                                             ray_r_mu_intersects_ground\r\n"
")\r\n"
"{\r\n"
"    vec4 uvwz = tg_get_scattering_texture_uvwz_from_r_mu_mu_s_nu(atmosphere, r, mu, mu_s, nu, ray_r_mu_intersects_ground);\r\n"
"    tg_number tex_coord_x = uvwz.x * tg_number(TG_SCATTERING_TEXTURE_NU_SIZE - 1);\r\n"
"    tg_number tex_x = floor(tex_coord_x);\r\n"
"    tg_number lerp = tex_coord_x - tex_x;\r\n"
"    vec3 uvw0 = vec3((tex_x + uvwz.y) / tg_number(TG_SCATTERING_TEXTURE_NU_SIZE), uvwz.z, uvwz.w);\r\n"
"    vec3 uvw1 = vec3((tex_x + 1.0 + uvwz.y) / tg_number(TG_SCATTERING_TEXTURE_NU_SIZE), uvwz.z, uvwz.w);\r\n"
"    return tg_abstract_spectrum(texture(scattering_texture, uvw0) * (1.0 - lerp) + texture(scattering_texture, uvw1) * lerp);\r\n"
"}\r\n"
"\r\n"
"tg_radiance_spectrum tg_get_scattering(\r\n"
"    TG_IN(tg_atmosphere_parameters)         atmosphere,\r\n"
"    TG_IN(tg_reduced_scattering_texture)    single_rayleigh_scattering_texture,\r\n"
"    TG_IN(tg_reduced_scattering_texture)    single_mie_scattering_texture,\r\n"
"    TG_IN(tg_scattering_texture)            multiple_scattering_texture,\r\n"
"    tg_length                               r,\r\n"
"    tg_number                               mu,\r\n"
"    tg_number                               mu_s,\r\n"
"    tg_number                               nu,\r\n"
"    bool                                    ray_r_mu_intersects_ground,\r\n"
"    int                                     scattering_order\r\n"
")\r\n"
"{\r\n"
"    if (scattering_order == 1)\r\n"
"    {\r\n"
"      tg_irradiance_spectrum rayleigh = tg_get_scattering(atmosphere, single_rayleigh_scattering_texture, r, mu, mu_s, nu, ray_r_mu_intersects_ground);\r\n"
"      tg_irradiance_spectrum mie = tg_get_scattering(atmosphere, single_mie_scattering_texture, r, mu, mu_s, nu, ray_r_mu_intersects_ground);\r\n"
"      return rayleigh * tg_rayleigh_phase_function(nu) + mie * tg_mie_phase_function(atmosphere.mie_phase_function_g, nu);\r\n"
"    }\r\n"
"    else\r\n"
"    {\r\n"
"      return tg_get_scattering(atmosphere, multiple_scattering_texture, r, mu, mu_s, nu, ray_r_mu_intersects_ground);\r\n"
"    }\r\n"
"}\r\n"
"\r\n"
"tg_irradiance_spectrum tg_get_irradiance(TG_IN(tg_atmosphere_parameters) atmosphere, TG_IN(tg_irradiance_texture) irradiance_texture, tg_length r, tg_number mu_s);\r\n"
"\r\n"
"tg_radiance_density_spectrum tg_compute_scattering_density(\r\n"
"    TG_IN(tg_atmosphere_parameters)         atmosphere,\r\n"
"    TG_IN(tg_transmittance_texture)         transmittance_texture,\r\n"
"    TG_IN(tg_reduced_scattering_texture)    single_rayleigh_scattering_texture,\r\n"
"    TG_IN(tg_reduced_scattering_texture)    single_mie_scattering_texture,\r\n"
"    TG_IN(tg_scattering_texture)            multiple_scattering_texture,\r\n"
"    TG_IN(tg_irradiance_texture)            irradiance_texture,\r\n"
"    tg_length                               r,\r\n"
"    tg_number                               mu,\r\n"
"    tg_number                               mu_s,\r\n"
"    tg_number                               nu,\r\n"
"    int                                     scattering_order\r\n"
")\r\n"
"{\r\n"
"    TG_ASSERT(r >= atmosphere.bottom_radius && r <= atmosphere.top_radius);\r\n"
"    TG_ASSERT(mu >= -1.0 && mu <= 1.0);\r\n"
"    TG_ASSERT(mu_s >= -1.0 && mu_s <= 1.0);\r\n"
"    TG_ASSERT(nu >= -1.0 && nu <= 1.0);\r\n"
"    TG_ASSERT(scattering_order >= 2);\r\n"
"    \r\n"
"    vec3 zenith_direction = vec3(0.0, 0.0, 1.0);\r\n"
"    vec3 omega = vec3(sqrt(1.0 - mu * mu), 0.0, mu);\r\n"
"    tg_number sun_dir_x = omega.x == 0.0 ? 0.0 : (nu - mu * mu_s) / omega.x;\r\n"
"    tg_number sun_dir_y = sqrt(max(1.0 - sun_dir_x * sun_dir_x - mu_s * mu_s, 0.0));\r\n"
"    vec3 omega_s = vec3(sun_dir_x, sun_dir_y, mu_s);\r\n"
"    \r\n"
"    const int TG_SAMPLE_COUNT = 16;\r\n"
"    const tg_angle dphi = pi / tg_number(TG_SAMPLE_COUNT);\r\n"
"    const tg_angle dtheta = pi / tg_number(TG_SAMPLE_COUNT);\r\n"
"    tg_radiance_density_spectrum rayleigh_mie = tg_radiance_density_spectrum(0.0 * watt_per_cubic_meter_per_sr_per_nm);\r\n"
"    \r\n"
"    for (int l = 0; l < TG_SAMPLE_COUNT; ++l)\r\n"
"    {\r\n"
"        tg_angle theta = (tg_number(l) + 0.5) * dtheta;\r\n"
"        tg_number cos_theta = cos(theta);\r\n"
"        tg_number sin_theta = sin(theta);\r\n"
"        bool ray_r_theta_intersects_ground = tg_ray_intersects_ground(atmosphere, r, cos_theta);\r\n"
"        \r\n"
"        tg_length distance_to_ground = 0.0 * m;\r\n"
"        tg_dimensionless_spectrum transmittance_to_ground = tg_dimensionless_spectrum(0.0);\r\n"
"        tg_dimensionless_spectrum ground_albedo = tg_dimensionless_spectrum(0.0);\r\n"
"        if (ray_r_theta_intersects_ground)\r\n"
"        {\r\n"
"            distance_to_ground = tg_distance_to_bottom_atmosphere_boundary(atmosphere, r, cos_theta);\r\n"
"            transmittance_to_ground = tg_get_transmittance(atmosphere, transmittance_texture, r, cos_theta, distance_to_ground, true);\r\n"
"            ground_albedo = atmosphere.ground_albedo;\r\n"
"        }\r\n"
"        \r\n"
"        for (int m = 0; m < 2 * TG_SAMPLE_COUNT; ++m)\r\n"
"        {\r\n"
"            tg_angle phi = (tg_number(m) + 0.5) * dphi;\r\n"
"            vec3 omega_i = vec3(cos(phi) * sin_theta, sin(phi) * sin_theta, cos_theta);\r\n"
"            tg_solid_angle domega_i = (dtheta / rad) * (dphi / rad) * sin(theta) * sr;\r\n"
"            \r\n"
"            tg_number nu1 = dot(omega_s, omega_i);\r\n"
"            tg_radiance_spectrum incident_radiance = tg_get_scattering(atmosphere,\r\n"
"                single_rayleigh_scattering_texture, single_mie_scattering_texture,\r\n"
"                multiple_scattering_texture, r, omega_i.z, mu_s, nu1,\r\n"
"                ray_r_theta_intersects_ground, scattering_order - 1);\r\n"
"            \r\n"
"            vec3 ground_normal = normalize(zenith_direction * r + omega_i * distance_to_ground);\r\n"
"            tg_irradiance_spectrum ground_irradiance = tg_get_irradiance(atmosphere, irradiance_texture, atmosphere.bottom_radius, dot(ground_normal, omega_s));\r\n"
"            incident_radiance += transmittance_to_ground * ground_albedo * (1.0 / (TG_PI * sr)) * ground_irradiance;\r\n"
"            \r\n"
"            tg_number nu2 = dot(omega, omega_i);\r\n"
"            tg_number rayleigh_density = tg_get_profile_density(atmosphere.rayleigh_density, r - atmosphere.bottom_radius);\r\n"
"            tg_number mie_density = tg_get_profile_density(atmosphere.mie_density, r - atmosphere.bottom_radius);\r\n"
"            rayleigh_mie += incident_radiance * (\r\n"
"                atmosphere.rayleigh_scattering * rayleigh_density *\r\n"
"                    tg_rayleigh_phase_function(nu2) +\r\n"
"                atmosphere.mie_scattering * mie_density *\r\n"
"                    tg_mie_phase_function(atmosphere.mie_phase_function_g, nu2)) *\r\n"
"                domega_i;\r\n"
"        }\r\n"
"    }\r\n"
"    return rayleigh_mie;\r\n"
"}\r\n"
"\r\n"
"tg_radiance_spectrum tg_compute_multiple_scattering(\r\n"
"    TG_IN(tg_atmosphere_parameters)         atmosphere,\r\n"
"    TG_IN(tg_transmittance_texture)         transmittance_texture,\r\n"
"    TG_IN(tg_scattering_density_texture)    scattering_density_texture,\r\n"
"    tg_length                               r,\r\n"
"    tg_number                               mu,\r\n"
"    tg_number                               mu_s,\r\n"
"    tg_number                               nu,\r\n"
"    bool                                    ray_r_mu_intersects_ground\r\n"
")\r\n"
"{\r\n"
"    TG_ASSERT(r >= atmosphere.bottom_radius && r <= atmosphere.top_radius);\r\n"
"    TG_ASSERT(mu >= -1.0 && mu <= 1.0);\r\n"
"    TG_ASSERT(mu_s >= -1.0 && mu_s <= 1.0);\r\n"
"    TG_ASSERT(nu >= -1.0 && nu <= 1.0);\r\n"
"    \r\n"
"    const int TG_SAMPLE_COUNT = 50;\r\n"
"    tg_length dx = tg_distance_to_nearest_atmosphere_boundary(atmosphere, r, mu, ray_r_mu_intersects_ground) / tg_number(TG_SAMPLE_COUNT);\r\n"
"    tg_radiance_spectrum rayleigh_mie_sum = tg_radiance_spectrum(0.0 * watt_per_square_meter_per_sr_per_nm);\r\n"
"    for (int i = 0; i <= TG_SAMPLE_COUNT; ++i)\r\n"
"    {\r\n"
"        tg_length d_i = tg_number(i) * dx;\r\n"
"        \r\n"
"        tg_length r_i = tg_clamp_radius(atmosphere, sqrt(d_i * d_i + 2.0 * r * mu * d_i + r * r));\r\n"
"        tg_number mu_i = tg_clamp_cosine((r * mu + d_i) / r_i);\r\n"
"        tg_number mu_s_i = tg_clamp_cosine((r * mu_s + d_i * nu) / r_i);\r\n"
"        \r\n"
"        tg_radiance_spectrum rayleigh_mie_i =\r\n"
"            tg_get_scattering(\r\n"
"                atmosphere, scattering_density_texture, r_i, mu_i, mu_s_i, nu,\r\n"
"                ray_r_mu_intersects_ground) *\r\n"
"            tg_get_transmittance(\r\n"
"                atmosphere, transmittance_texture, r, mu, d_i,\r\n"
"                ray_r_mu_intersects_ground) *\r\n"
"            dx;\r\n"
"        tg_number weight_i = (i == 0 || i == TG_SAMPLE_COUNT) ? 0.5 : 1.0;\r\n"
"        rayleigh_mie_sum += rayleigh_mie_i * weight_i;\r\n"
"    }\r\n"
"    return rayleigh_mie_sum;\r\n"
"}\r\n"
"\r\n"
"tg_radiance_density_spectrum tg_compute_scattering_density_texture(\r\n"
"    TG_IN(tg_atmosphere_parameters)         atmosphere,\r\n"
"    TG_IN(tg_transmittance_texture)         transmittance_texture,\r\n"
"    TG_IN(tg_reduced_scattering_texture)    single_rayleigh_scattering_texture,\r\n"
"    TG_IN(tg_reduced_scattering_texture)    single_mie_scattering_texture,\r\n"
"    TG_IN(tg_scattering_texture)            multiple_scattering_texture,\r\n"
"    TG_IN(tg_irradiance_texture)            irradiance_texture,\r\n"
"    TG_IN(vec3)                             frag_coord,\r\n"
"    int                                     scattering_order\r\n"
")\r\n"
"{\r\n"
"    tg_length r;\r\n"
"    tg_number mu;\r\n"
"    tg_number mu_s;\r\n"
"    tg_number nu;\r\n"
"    bool ray_r_mu_intersects_ground;\r\n"
"    tg_get_r_mu_mu_s_nu_from_scattering_texture_frag_coord(atmosphere, frag_coord, r, mu, mu_s, nu, ray_r_mu_intersects_ground);\r\n"
"    return tg_compute_scattering_density(atmosphere, transmittance_texture,\r\n"
"        single_rayleigh_scattering_texture, single_mie_scattering_texture,\r\n"
"        multiple_scattering_texture, irradiance_texture, r, mu, mu_s, nu,\r\n"
"        scattering_order\r\n"
"    );\r\n"
"}\r\n"
"\r\n"
"tg_radiance_spectrum tg_compute_multiple_scattering_texture(\r\n"
"    TG_IN(tg_atmosphere_parameters)         atmosphere,\r\n"
"    TG_IN(tg_transmittance_texture)         transmittance_texture,\r\n"
"    TG_IN(tg_scattering_density_texture)    scattering_density_texture,\r\n"
"    TG_IN(vec3)                             frag_coord,\r\n"
"    TG_OUT(tg_number)                       nu\r\n"
")\r\n"
"{\r\n"
"    tg_length r;\r\n"
"    tg_number mu;\r\n"
"    tg_number mu_s;\r\n"
"    bool ray_r_mu_intersects_ground;\r\n"
"    tg_get_r_mu_mu_s_nu_from_scattering_texture_frag_coord(atmosphere, frag_coord, r, mu, mu_s, nu, ray_r_mu_intersects_ground);\r\n"
"    return tg_compute_multiple_scattering(atmosphere, transmittance_texture, scattering_density_texture, r, mu, mu_s, nu, ray_r_mu_intersects_ground);\r\n"
"}\r\n"
"\r\n"
"tg_irradiance_spectrum tg_compute_direct_irradiance(\r\n"
"    TG_IN(tg_atmosphere_parameters)    atmosphere,\r\n"
"    TG_IN(tg_transmittance_texture)    transmittance_texture,\r\n"
"    tg_length                          r,\r\n"
"    tg_number                          mu_s\r\n"
")\r\n"
"{\r\n"
"  TG_ASSERT(r >= atmosphere.bottom_radius && r <= atmosphere.top_radius);\r\n"
"  TG_ASSERT(mu_s >= -1.0 && mu_s <= 1.0);\r\n"
"\r\n"
"  tg_number alpha_s = atmosphere.sun_angular_radius / rad;\r\n"
"  tg_number average_cosine_factor = mu_s < -alpha_s ? 0.0 : (mu_s > alpha_s ? mu_s : (mu_s + alpha_s) * (mu_s + alpha_s) / (4.0 * alpha_s));\r\n"
"\r\n"
"  return atmosphere.solar_irradiance * tg_get_transmittance_to_top_atmosphere_boundary(atmosphere, transmittance_texture, r, mu_s) * average_cosine_factor;\r\n"
"\r\n"
"}\r\n"
"\r\n"
"tg_irradiance_spectrum tg_compute_indirect_irradiance(\r\n"
"    TG_IN(tg_atmosphere_parameters)         atmosphere,\r\n"
"    TG_IN(tg_reduced_scattering_texture)    single_rayleigh_scattering_texture,\r\n"
"    TG_IN(tg_reduced_scattering_texture)    single_mie_scattering_texture,\r\n"
"    TG_IN(tg_scattering_texture)            multiple_scattering_texture,\r\n"
"    tg_length                               r,\r\n"
"    tg_number                               mu_s,\r\n"
"    int                                     scattering_order\r\n"
")\r\n"
"{\r\n"
"    TG_ASSERT(r >= atmosphere.bottom_radius && r <= atmosphere.top_radius);\r\n"
"    TG_ASSERT(mu_s >= -1.0 && mu_s <= 1.0);\r\n"
"    TG_ASSERT(scattering_order >= 1);\r\n"
"  \r\n"
"    const int TG_SAMPLE_COUNT = 32;\r\n"
"    const tg_angle dphi = pi / tg_number(TG_SAMPLE_COUNT);\r\n"
"    const tg_angle dtheta = pi / tg_number(TG_SAMPLE_COUNT);\r\n"
"  \r\n"
"    tg_irradiance_spectrum result = tg_irradiance_spectrum(0.0 * watt_per_square_meter_per_nm);\r\n"
"    vec3 omega_s = vec3(sqrt(1.0 - mu_s * mu_s), 0.0, mu_s);\r\n"
"    for (int j = 0; j < TG_SAMPLE_COUNT / 2; ++j)\r\n"
"    {\r\n"
"        tg_angle theta = (tg_number(j) + 0.5) * dtheta;\r\n"
"        for (int i = 0; i < 2 * TG_SAMPLE_COUNT; ++i) {\r\n"
"            tg_angle phi = (tg_number(i) + 0.5) * dphi;\r\n"
"            vec3 omega = vec3(cos(phi) * sin(theta), sin(phi) * sin(theta), cos(theta));\r\n"
"            tg_solid_angle domega = (dtheta / rad) * (dphi / rad) * sin(theta) * sr;\r\n"
"            \r\n"
"            tg_number nu = dot(omega, omega_s);\r\n"
"            result += tg_get_scattering(atmosphere, single_rayleigh_scattering_texture,\r\n"
"                single_mie_scattering_texture, multiple_scattering_texture,\r\n"
"                r, omega.z, mu_s, nu, false, scattering_order)\r\n"
"                    * omega.z * domega;\r\n"
"        }\r\n"
"    }\r\n"
"    return result;\r\n"
"}\r\n"
"\r\n"
"vec2 tg_get_irradiance_texture_uv_from_r_mu_s(TG_IN(tg_atmosphere_parameters) atmosphere, tg_length r, tg_number mu_s)\r\n"
"{\r\n"
"    TG_ASSERT(r >= atmosphere.bottom_radius && r <= atmosphere.top_radius);\r\n"
"    TG_ASSERT(mu_s >= -1.0 && mu_s <= 1.0);\r\n"
"    \r\n"
"    tg_number x_r = (r - atmosphere.bottom_radius) / (atmosphere.top_radius - atmosphere.bottom_radius);\r\n"
"    tg_number x_mu_s = mu_s * 0.5 + 0.5;\r\n"
"    return vec2(tg_get_texture_coord_from_unit_range(x_mu_s, TG_IRRADIANCE_TEXTURE_WIDTH), tg_get_texture_coord_from_unit_range(x_r, TG_IRRADIANCE_TEXTURE_HEIGHT));\r\n"
"}\r\n"
"\r\n"
"void tg_get_r_mu_s_from_irradiance_texture_uv(TG_IN(tg_atmosphere_parameters) atmosphere, TG_IN(vec2) uv, TG_OUT(tg_length) r, TG_OUT(tg_number) mu_s)\r\n"
"{\r\n"
"    TG_ASSERT(uv.x >= 0.0 && uv.x <= 1.0);\r\n"
"    TG_ASSERT(uv.y >= 0.0 && uv.y <= 1.0);\r\n"
"    \r\n"
"    tg_number x_mu_s = tg_get_unit_range_from_texture_coord(uv.x, TG_IRRADIANCE_TEXTURE_WIDTH);\r\n"
"    tg_number x_r = tg_get_unit_range_from_texture_coord(uv.y, TG_IRRADIANCE_TEXTURE_HEIGHT);\r\n"
"    r = atmosphere.bottom_radius + x_r * (atmosphere.top_radius - atmosphere.bottom_radius);\r\n"
"    mu_s = tg_clamp_cosine(2.0 * x_mu_s - 1.0);\r\n"
"}\r\n"
"\r\n"
"const vec2 TG_IRRADIANCE_TEXTURE_SIZE = vec2(TG_IRRADIANCE_TEXTURE_WIDTH, TG_IRRADIANCE_TEXTURE_HEIGHT);\r\n"
"\r\n"
"tg_irradiance_spectrum tg_compute_direct_irradiance_texture(TG_IN(tg_atmosphere_parameters) atmosphere, TG_IN(tg_transmittance_texture) transmittance_texture, TG_IN(vec2) frag_coord)\r\n"
"{\r\n"
"  tg_length r;\r\n"
"  tg_number mu_s;\r\n"
"  tg_get_r_mu_s_from_irradiance_texture_uv(atmosphere, frag_coord / TG_IRRADIANCE_TEXTURE_SIZE, r, mu_s);\r\n"
"  return tg_compute_direct_irradiance(atmosphere, transmittance_texture, r, mu_s);\r\n"
"}\r\n"
"\r\n"
"tg_irradiance_spectrum tg_compute_indirect_irradiance_texture(\r\n"
"    TG_IN(tg_atmosphere_parameters)         atmosphere,\r\n"
"    TG_IN(tg_reduced_scattering_texture)    single_rayleigh_scattering_texture,\r\n"
"    TG_IN(tg_reduced_scattering_texture)    single_mie_scattering_texture,\r\n"
"    TG_IN(tg_scattering_texture)            multiple_scattering_texture,\r\n"
"    TG_IN(vec2)                             frag_coord,\r\n"
"    int                                     scattering_order\r\n"
")\r\n"
"{\r\n"
"    tg_length r;\r\n"
"    tg_number mu_s;\r\n"
"    tg_get_r_mu_s_from_irradiance_texture_uv(atmosphere, frag_coord / TG_IRRADIANCE_TEXTURE_SIZE, r, mu_s);\r\n"
"    return tg_compute_indirect_irradiance(\r\n"
"        atmosphere, single_rayleigh_scattering_texture, single_mie_scattering_texture, multiple_scattering_texture, r, mu_s, scattering_order\r\n"
"    );\r\n"
"}\r\n"
"\r\n"
"tg_irradiance_spectrum tg_get_irradiance(TG_IN(tg_atmosphere_parameters) atmosphere, TG_IN(tg_irradiance_texture) irradiance_texture, tg_length r, tg_number mu_s)\r\n"
"{\r\n"
"    vec2 uv = tg_get_irradiance_texture_uv_from_r_mu_s(atmosphere, r, mu_s);\r\n"
"    return tg_irradiance_spectrum(texture(irradiance_texture, uv));\r\n"
"}\r\n"
"\r\n"
"#ifdef TG_COMBINED_SCATTERING_TEXTURES\r\n"
"\r\n"
"vec3 tg_get_extrapolated_single_mie_scattering(TG_IN(tg_atmosphere_parameters) atmosphere, TG_IN(vec4) scattering)\r\n"
"{\r\n"
"    if (scattering.r <= 0.0)\r\n"
"    {\r\n"
"      return vec3(0.0);\r\n"
"    }\r\n"
"    return scattering.rgb * scattering.a / scattering.r *\r\n"
"        (atmosphere.rayleigh_scattering.r / atmosphere.mie_scattering.r) *\r\n"
"        (atmosphere.mie_scattering / atmosphere.rayleigh_scattering);\r\n"
"}\r\n"
"\r\n"
"#endif\r\n"
"\r\n"
"tg_irradiance_spectrum tg_get_combined_scattering(\r\n"
"    TG_IN(tg_atmosphere_parameters)         atmosphere,\r\n"
"    TG_IN(tg_reduced_scattering_texture)    scattering_texture,\r\n"
"    TG_IN(tg_reduced_scattering_texture)    single_mie_scattering_texture,\r\n"
"    tg_length                               r,\r\n"
"    tg_number                               mu,\r\n"
"    tg_number                               mu_s,\r\n"
"    tg_number                               nu,\r\n"
"    bool                                    ray_r_mu_intersects_ground,\r\n"
"    TG_OUT(tg_irradiance_spectrum)          single_mie_scattering\r\n"
")\r\n"
"{\r\n"
"    vec4 uvwz = tg_get_scattering_texture_uvwz_from_r_mu_mu_s_nu(atmosphere, r, mu, mu_s, nu, ray_r_mu_intersects_ground);\r\n"
"    tg_number tex_coord_x = uvwz.x * tg_number(TG_SCATTERING_TEXTURE_NU_SIZE - 1);\r\n"
"    tg_number tex_x = floor(tex_coord_x);\r\n"
"    tg_number lerp = tex_coord_x - tex_x;\r\n"
"    vec3 uvw0 = vec3((tex_x + uvwz.y) / tg_number(TG_SCATTERING_TEXTURE_NU_SIZE), uvwz.z, uvwz.w);\r\n"
"    vec3 uvw1 = vec3((tex_x + 1.0 + uvwz.y) / tg_number(TG_SCATTERING_TEXTURE_NU_SIZE), uvwz.z, uvwz.w);\r\n"
"#ifdef TG_COMBINED_SCATTERING_TEXTURES\r\n"
"    vec4 combined_scattering =\r\n"
"        texture(scattering_texture, uvw0) * (1.0 - lerp) +\r\n"
"        texture(scattering_texture, uvw1) * lerp;\r\n"
"    tg_irradiance_spectrum scattering = tg_irradiance_spectrum(combined_scattering);\r\n"
"    single_mie_scattering = tg_get_extrapolated_single_mie_scattering(atmosphere, combined_scattering);\r\n"
"#else\r\n"
"    tg_irradiance_spectrum scattering = tg_irradiance_spectrum(\r\n"
"        texture(scattering_texture, uvw0) * (1.0 - lerp) +\r\n"
"        texture(scattering_texture, uvw1) * lerp);\r\n"
"    single_mie_scattering = tg_irradiance_spectrum(\r\n"
"        texture(single_mie_scattering_texture, uvw0) * (1.0 - lerp) +\r\n"
"        texture(single_mie_scattering_texture, uvw1) * lerp);\r\n"
"#endif\r\n"
"    return scattering;\r\n"
"}\r\n"
"\r\n"
"tg_radiance_spectrum tg_get_sky_radiance(\r\n"
"    TG_IN(tg_atmosphere_parameters)         atmosphere,\r\n"
"    TG_IN(tg_transmittance_texture)         transmittance_texture,\r\n"
"    TG_IN(tg_reduced_scattering_texture)    scattering_texture,\r\n"
"    TG_IN(tg_reduced_scattering_texture)    single_mie_scattering_texture,\r\n"
"    tg_position                             camera,\r\n"
"    TG_IN(tg_direction)                     view_ray,\r\n"
"    tg_length                               shadow_length,\r\n"
"    TG_IN(tg_direction)                     sun_direction,\r\n"
"    TG_OUT(tg_dimensionless_spectrum)       transmittance\r\n"
")\r\n"
"{\r\n"
"    tg_length r = length(camera);\r\n"
"    tg_length rmu = dot(camera, view_ray);\r\n"
"    tg_length distance_to_top_atmosphere_boundary = -rmu - sqrt(rmu * rmu - r * r + atmosphere.top_radius * atmosphere.top_radius);\r\n"
"    if (distance_to_top_atmosphere_boundary > 0.0 * m)\r\n"
"    {\r\n"
"        camera = camera + view_ray * distance_to_top_atmosphere_boundary;\r\n"
"        r = atmosphere.top_radius;\r\n"
"        rmu += distance_to_top_atmosphere_boundary;\r\n"
"    }\r\n"
"    else if (r > atmosphere.top_radius)\r\n"
"    {\r\n"
"        transmittance = tg_dimensionless_spectrum(1.0);\r\n"
"        return tg_radiance_spectrum(0.0 * watt_per_square_meter_per_sr_per_nm);\r\n"
"    }\r\n"
"    tg_number mu = rmu / r;\r\n"
"    tg_number mu_s = dot(camera, sun_direction) / r;\r\n"
"    tg_number nu = dot(view_ray, sun_direction);\r\n"
"    bool ray_r_mu_intersects_ground = tg_ray_intersects_ground(atmosphere, r, mu);\r\n"
"    \r\n"
"    transmittance = ray_r_mu_intersects_ground ? tg_dimensionless_spectrum(0.0) : tg_get_transmittance_to_top_atmosphere_boundary(atmosphere, transmittance_texture, r, mu);\r\n"
"    tg_irradiance_spectrum single_mie_scattering;\r\n"
"    tg_irradiance_spectrum scattering;\r\n"
"    if (shadow_length == 0.0 * m)\r\n"
"    {\r\n"
"        scattering = tg_get_combined_scattering(\r\n"
"            atmosphere, scattering_texture, single_mie_scattering_texture,\r\n"
"            r, mu, mu_s, nu, ray_r_mu_intersects_ground,\r\n"
"            single_mie_scattering);\r\n"
"    }\r\n"
"    else\r\n"
"    {\r\n"
"        tg_length d = shadow_length;\r\n"
"        tg_length r_p = tg_clamp_radius(atmosphere, sqrt(d * d + 2.0 * r * mu * d + r * r));\r\n"
"        tg_number mu_p = (r * mu + d) / r_p;\r\n"
"        tg_number mu_s_p = (r * mu_s + d * nu) / r_p;\r\n"
"        \r\n"
"        scattering = tg_get_combined_scattering(\r\n"
"            atmosphere, scattering_texture, single_mie_scattering_texture,\r\n"
"            r_p, mu_p, mu_s_p, nu, ray_r_mu_intersects_ground,\r\n"
"            single_mie_scattering);\r\n"
"        tg_dimensionless_spectrum shadow_transmittance =\r\n"
"            tg_get_transmittance(atmosphere, transmittance_texture, r, mu, shadow_length, ray_r_mu_intersects_ground);\r\n"
"        scattering = scattering * shadow_transmittance;\r\n"
"        single_mie_scattering = single_mie_scattering * shadow_transmittance;\r\n"
"    }\r\n"
"    return scattering * tg_rayleigh_phase_function(nu) + single_mie_scattering * tg_mie_phase_function(atmosphere.mie_phase_function_g, nu);\r\n"
"}\r\n"
"\r\n"
"tg_radiance_spectrum tg_get_sky_radiance_to_point(\r\n"
"    TG_IN(tg_atmosphere_parameters)         atmosphere,\r\n"
"    TG_IN(tg_transmittance_texture)         transmittance_texture,\r\n"
"    TG_IN(tg_reduced_scattering_texture)    scattering_texture,\r\n"
"    TG_IN(tg_reduced_scattering_texture)    single_mie_scattering_texture,\r\n"
"    tg_position                             camera,\r\n"
"    TG_IN(tg_position)                      point,\r\n"
"    tg_length                               shadow_length,\r\n"
"    TG_IN(tg_direction)                     sun_direction,\r\n"
"    TG_OUT(tg_dimensionless_spectrum)       transmittance\r\n"
")\r\n"
"{\r\n"
"    tg_direction view_ray = normalize(point - camera);\r\n"
"    tg_length r = length(camera);\r\n"
"    tg_length rmu = dot(camera, view_ray);\r\n"
"    tg_length distance_to_top_atmosphere_boundary = -rmu - sqrt(rmu * rmu - r * r + atmosphere.top_radius * atmosphere.top_radius);\r\n"
"    if (distance_to_top_atmosphere_boundary > 0.0 * m)\r\n"
"    {\r\n"
"        camera = camera + view_ray * distance_to_top_atmosphere_boundary;\r\n"
"        r = atmosphere.top_radius;\r\n"
"        rmu += distance_to_top_atmosphere_boundary;\r\n"
"    }\r\n"
"    \r\n"
"    tg_number mu = rmu / r;\r\n"
"    tg_number mu_s = dot(camera, sun_direction) / r;\r\n"
"    tg_number nu = dot(view_ray, sun_direction);\r\n"
"    tg_length d = length(point - camera);\r\n"
"    bool ray_r_mu_intersects_ground = tg_ray_intersects_ground(atmosphere, r, mu);\r\n"
"    \r\n"
"    transmittance = tg_get_transmittance(atmosphere, transmittance_texture, r, mu, d, ray_r_mu_intersects_ground);\r\n"
"    \r\n"
"    tg_irradiance_spectrum single_mie_scattering;\r\n"
"    tg_irradiance_spectrum scattering = tg_get_combined_scattering(\r\n"
"        atmosphere, scattering_texture, single_mie_scattering_texture,\r\n"
"        r, mu, mu_s, nu, ray_r_mu_intersects_ground,\r\n"
"        single_mie_scattering);\r\n"
"    \r\n"
"    d = max(d - shadow_length, 0.0 * m);\r\n"
"    tg_length r_p = tg_clamp_radius(atmosphere, sqrt(d * d + 2.0 * r * mu * d + r * r));\r\n"
"    tg_number mu_p = (r * mu + d) / r_p;\r\n"
"    tg_number mu_s_p = (r * mu_s + d * nu) / r_p;\r\n"
"    \r\n"
"    tg_irradiance_spectrum single_mie_scattering_p;\r\n"
"    tg_irradiance_spectrum scattering_p = tg_get_combined_scattering(\r\n"
"        atmosphere, scattering_texture, single_mie_scattering_texture,\r\n"
"        r_p, mu_p, mu_s_p, nu, ray_r_mu_intersects_ground,\r\n"
"        single_mie_scattering_p);\r\n"
"    \r\n"
"    tg_dimensionless_spectrum shadow_transmittance = transmittance;\r\n"
"    if (shadow_length > 0.0 * m)\r\n"
"    {\r\n"
"        shadow_transmittance = tg_get_transmittance(atmosphere, transmittance_texture, r, mu, d, ray_r_mu_intersects_ground);\r\n"
"    }\r\n"
"    scattering = scattering - shadow_transmittance * scattering_p;\r\n"
"    single_mie_scattering = single_mie_scattering - shadow_transmittance * single_mie_scattering_p;\r\n"
"#ifdef TG_COMBINED_SCATTERING_TEXTURES\r\n"
"    single_mie_scattering = tg_get_extrapolated_single_mie_scattering(atmosphere, vec4(scattering, single_mie_scattering.r));\r\n"
"#endif\r\n"
"\r\n"
"    single_mie_scattering = single_mie_scattering * smoothstep(tg_number(0.0), tg_number(0.01), mu_s);\r\n"
"    \r\n"
"    return scattering * tg_rayleigh_phase_function(nu) + single_mie_scattering * tg_mie_phase_function(atmosphere.mie_phase_function_g, nu);\r\n"
"}\r\n"
"\r\n"
"tg_irradiance_spectrum tg_get_sun_and_sky_irradiance(\r\n"
"    TG_IN(tg_atmosphere_parameters)    atmosphere,\r\n"
"    TG_IN(tg_transmittance_texture)    transmittance_texture,\r\n"
"    TG_IN(tg_irradiance_texture)       irradiance_texture,\r\n"
"    TG_IN(tg_position)                 point,\r\n"
"    TG_IN(tg_direction)                normal,\r\n"
"    TG_IN(tg_direction)                sun_direction,\r\n"
"    TG_OUT(tg_irradiance_spectrum)     sky_irradiance\r\n"
")\r\n"
"{\r\n"
"    tg_length r = length(point);\r\n"
"    tg_number mu_s = dot(point, sun_direction) / r;\r\n"
"    \r\n"
"    sky_irradiance = tg_get_irradiance(atmosphere, irradiance_texture, r, mu_s) * (1.0 + dot(normal, point) / r) * 0.5;\r\n"
"    \r\n"
"    return atmosphere.solar_irradiance *\r\n"
"        tg_get_transmittance_to_sun(\r\n"
"            atmosphere, transmittance_texture, r, mu_s) *\r\n"
"        max(dot(normal, sun_direction), 0.0);\r\n"
"}\r\n";

#endif
